<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Monarch Crypto Monitor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            color: #333;
            padding: 20px;
            text-align: center;
        }

        h1 {
            color: #004d99;
        }

        .card-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }

        .crypto-card {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            width: 300px;
            text-align: left;
            transition: transform 0.3s;
        }

        .crypto-card:hover {
            transform: translateY(-5px);
        }

        .crypto-card h2 {
            margin-top: 0;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .price, .rsi, .correction {
            font-weight: bold;
            color: #007bff;
        }

        .status {
            margin-top: 15px;
            font-weight: bold;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-size: 0.9em;
        }

        .status.ready {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.wait {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }

        .status.not-ready {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .chart-container {
            position: relative;
            height: 250px;
            width: 100%;
            margin-top: 15px;
        }

        #sentiment-status {
            margin-top: 30px;
            font-size: 1.1em;
            font-weight: bold;
        }

        .last-updated {
            margin-top: 20px;
            font-size: 0.9em;
            color: #666;
        }

        .data-row {
            margin: 8px 0;
            font-size: 0.95em;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Grand Monarch Investments Pty - Crypto Entry Monitor</h1>
        <p>Monitoring XRP, UNI, SOL, and LINK for optimal entry (RSI (14-Day) < 30, >30% Correction, Fear Sentiment)</p>
        
        <div class="card-container">
            <div class="crypto-card" id="XRP">
                <h2>XRP</h2>
                <div class="data-row">Price: <span class="price">...</span></div>
                <div class="data-row">RSI (90-Day): <span class="rsi">...</span></div>
                <div class="data-row">Correction: <span class="correction">...</span></div>
                <div class="status-box"><span class="status">Checking...</span></div>
                <div class="chart-container">
                    <canvas id="chart-XRP"></canvas>
                </div>
            </div>
            
            <div class="crypto-card" id="UNI">
                <h2>Uniswap (UNI)</h2>
                <div class="data-row">Price: <span class="price">...</span></div>
                <div class="data-row">RSI (90-Day): <span class="rsi">...</span></div>
                <div class="data-row">Correction: <span class="correction">...</span></div>
                <div class="status-box"><span class="status">Checking...</span></div>
                <div class="chart-container">
                    <canvas id="chart-UNI"></canvas>
                </div>
            </div>
            
            <div class="crypto-card" id="SOL">
                <h2>Solana (SOL)</h2>
                <div class="data-row">Price: <span class="price">...</span></div>
                <div class="data-row">RSI (90-Day): <span class="rsi">...</span></div>
                <div class="data-row">Correction: <span class="correction">...</span></div>
                <div class="status-box"><span class="status">Checking...</span></div>
                <div class="chart-container">
                    <canvas id="chart-SOL"></canvas>
                </div>
            </div>
            
            <div class="crypto-card" id="LINK">
                <h2>Chainlink (LINK)</h2>
                <div class="data-row">Price: <span class="price">...</span></div>
                <div class="data-row">RSI (90-Day): <span class="rsi">...</span></div>
                <div class="data-row">Correction: <span class="correction">...</span></div>
                <div class="status-box"><span class="status">Checking...</span></div>
                <div class="chart-container">
                    <canvas id="chart-LINK"></canvas>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p id="sentiment-status">Market Sentiment (Fear & Greed Index): Checking...</p>
            <p class="last-updated">Last Updated: <span id="last-updated-time">...</span></p>
        </div>
    </div>
    
    <script>
        const coins = {
            'XRP': 'ripple',
            'UNI': 'uniswap',
            'SOL': 'solana',
            'LINK': 'chainlink'
        };
        
        const charts = {};

        // Calculate RSI
        function calculateRSI(prices, period = 14) {
            if (prices.length < period + 1) return null;
            
            let gains = 0, losses = 0;
            for (let i = 1; i <= period; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) gains += change;
                else losses += Math.abs(change);
            }
            
            let avgGain = gains / period;
            let avgLoss = losses / period;
            
            for (let i = period + 1; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) {
                    avgGain = (avgGain * (period - 1) + change) / period;
                    avgLoss = (avgLoss * (period - 1)) / period;
                } else {
                    avgGain = (avgGain * (period - 1)) / period;
                    avgLoss = (avgLoss * (period - 1) + Math.abs(change)) / period;
                }
            }
            
            const rs = avgGain / avgLoss;
            const rsi = 100 - (100 / (1 + rs));
            return rsi;
        }

        let currentSentiment = 'Checking...';

async function fetchSentiment() {
    try {
        const response = await fetch('https://api.alternative.me/fng/');
        const data = await response.json();
        const sentimentData = data.data[0];
        currentSentiment = `${sentimentData.value_classification} (${sentimentData.value})`;
        document.getElementById('sentiment-status').textContent = `Market Sentiment (Fear & Greed Index): ${currentSentiment}`;
        return sentimentData.value_classification;
    } catch (error) {
        console.error('Error fetching sentiment data:', error);
        document.getElementById('sentiment-status').textContent = `Market Sentiment (Fear & Greed Index): API Error`;
        return 'API Error';
    }
}

async function fetchCryptoData() {
    let sentimentClassification = 'Checking...';
    try {
        sentimentClassification = await fetchSentiment();
    } catch (e) {
        console.error('Initial sentiment fetch failed, proceeding with crypto data:', e);
        sentimentClassification = 'API Error';
    }
    
    try {
                const coinIds = Object.values(coins).join(',');
                const response = await fetch(
                    `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${coinIds}&order=market_cap_desc&per_page=250&sparkline=false`
                );
                const marketData = await response.json();
                
                // Fetch 90-day historical data for each coin
                const dataPromises = Object.entries(coins).map(async ([symbol, id]) => {
                    const histResponse = await fetch(
                        `https://api.coingecko.com/api/v3/coins/${id}/market_chart?vs_currency=usd&days=30`
                    );
                    const histData = await histResponse.json();
                    const prices = histData.prices.map(p => p[1]);
                    
// Find current price from market data
                    const current = marketData.find(m => m.id === id);
                    const currentPrice = current.current_price;
                    
                    // Calculate 30-day peak
                    const peak = Math.max(...prices);
                    const correctionPercent = ((peak - currentPrice) / peak) * 100;
                    
                    // Calculate 14-day RSI
                    const rsi14 = calculateRSI(prices, 14);
                    
                    return {
                        symbol,
                        currentPrice,
                        peak,
                        correctionPercent,
                        rsi14,
                        prices
                    };
                });
                
                                const allData = await Promise.all(dataPromises);
                updateDashboard(allData, sentimentClassification);
                
            } catch (error) {
                console.error('Error fetching crypto data:', error);
                setTimeout(fetchCryptoData, 120000); // Retry after 2 minutes
            }
        }

        function updateDashboard(dataArray, sentimentClassification) {
            dataArray.forEach(data => {
                const card = document.getElementById(data.symbol);
                const priceEl = card.querySelector('.price');
                const rsiEl = card.querySelector('.rsi');
                const correctionEl = card.querySelector('.correction');
                const statusEl = card.querySelector('.status');

                priceEl.textContent = `$${data.currentPrice.toFixed(4)}`;
                rsiEl.textContent = data.rsi14 ? data.rsi14.toFixed(2) : 'N/A';
                correctionEl.textContent = `${data.correctionPercent.toFixed(2)}%`;

                const rsiReady = data.rsi14 && data.rsi14 < 30;
                const correctionReady = data.correctionPercent >= 30;
                                const PERSISTENCE_WINDOW_MS = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
                const STORAGE_KEY = `entrySignalMet_${data.symbol}`;
                const storedSignal = localStorage.getItem(STORAGE_KEY);
                let signalTime = storedSignal ? parseInt(storedSignal) : null;

                // const allReady = rsiReady && correctionReady; // Removed duplicate declaration
                const sentimentReady = sentimentClassification === 'Fear' || sentimentClassification === 'Extreme Fear';

                                // Check if the signal is currently met
                if (rsiReady && correctionReady && sentimentReady) {
                    // If signal is met, store the current time if not already stored or if the stored signal has expired
                    if (!signalTime || (Date.now() - signalTime > PERSISTENCE_WINDOW_MS)) {
                        signalTime = Date.now();
                        localStorage.setItem(STORAGE_KEY, signalTime.toString());
                    }
                } else {
                    // If signal is NOT met, clear the stored signal
                    localStorage.removeItem(STORAGE_KEY);
                    signalTime = null;
                }

                // Determine the final status based on persistence logic
                if (signalTime && (Date.now() - signalTime <= PERSISTENCE_WINDOW_MS)) {
                    // Signal is met and within the 24-hour window
                    const timeRemaining = signalTime + PERSISTENCE_WINDOW_MS - Date.now();
                    const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
                    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
                    statusEl.textContent = `✅ ENTRY SIGNAL MET (Expires in ${hours}h ${minutes}m)`;
                    statusEl.className = 'status ready';
                } else if (rsiReady && correctionReady) {
                    // Technical conditions met, awaiting sentiment
                    statusEl.textContent = `✓ READY (Awaiting ${sentimentReady ? 'N/A' : 'Fear'})`;
                    statusEl.className = 'status wait';
                } else {
                    // Not ready
                    statusEl.textContent = '✗ Not Ready';
                    statusEl.className = 'status not-ready';
                }

                updateChart(data.symbol, data.prices, data.currentPrice);
            });

            document.getElementById('last-updated-time').textContent = new Date().toLocaleTimeString();
        }

        function updateChart(symbol, prices, currentPrice) {
            const ctx = document.getElementById(`chart-${symbol}`).getContext('2d');
            
            if (charts[symbol]) {
                charts[symbol].destroy();
            }

            charts[symbol] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: prices.map((_, i) => `Day ${i + 1}`),
                    datasets: [{
                        label: `${symbol} Price (90 days)`,
                        data: prices,
                        borderColor: '#007bff',
                        backgroundColor: 'rgba(0, 123, 255, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: { beginAtZero: false }
                    }
                }
            });
        }

        // Fetch data immediately and every 2 minutes
        fetchCryptoData();
        setInterval(fetchCryptoData, 120000);
    </script>
</body>
</html>

